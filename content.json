{"meta":{"title":"Dylan Tseng 的博客","subtitle":null,"description":null,"author":"Dylan Tseng","url":"https://dylantseng1915.github.io"},"pages":[{"title":"categories","date":"2021-02-14T15:51:40.000Z","updated":"2021-02-14T15:52:11.366Z","comments":false,"path":"categories/index.html","permalink":"https://dylantseng1915.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-14T15:51:28.000Z","updated":"2021-02-14T15:52:35.805Z","comments":false,"path":"tags/index.html","permalink":"https://dylantseng1915.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"详解Android触摸事件处理程序","slug":"详解Android触摸事件处理程序","date":"2017-01-12T07:30:16.000Z","updated":"2021-02-14T14:01:43.639Z","comments":true,"path":"2017/01/12/ckl66lfqo0006wuz1gbilhwno/","link":"","permalink":"https://dylantseng1915.github.io/2017/01/12/ckl66lfqo0006wuz1gbilhwno/","excerpt":"","text":"详解Android触摸事件处理程序在了解触摸时间处理程序之前，我们来了解这几个主角： dispatchTouchEvent(MotionEvent ev)：此方法允许 ViewGroup 在分派之前截获所有触摸事件 onInterceptTouchEvent(MotionEvent ev)：此方法允许 ViewGroup 监视分派给子视图的事件 onTouchEvent(MotionEvent ev)： 在发生触摸屏运动事件时调用 接下来展示一下工作界面，注意，Layout03是嵌套在Layout02里面的 图1.1布局文件 首先，按下Layout03，事件流程如图所示： 图1.2 按下的时候总共有触发两个事件：ACTION_DOWN和ACTION_UP，但是因为整个事件流程中并没有哪个组件消费了ACTION_DOWN事件，而只有在onTouchEvent中消费了ACTION_DOWN事件，后续事件ACTION_UP,ACTION_MOVE…才会触发，所以这里ACTION_DOWN事件一路挥歌直下，ACTION_UP则并没有发生。 我们让Layout02的onTouchEvent返回true，消费ACTION_DOWN事件，事件流程如图所示： 图1.3 可以看到Layout02的onTouchEvent消费ACTION_DOWN事件之后便不在往下传了，后续事件也随后开始出现，并且Layout02直接将后续事件派发给消费者。所以当一个组件消费了ACTION_DOWN事件时，后续事件从窗口传到该组件的dispatchTouchEvent之后便直接交给它的onTouchEvent方法处理 我们在Layout02的onInterceptTouchEvent里返回true，事件流程如下： 图1.4 这时候事件传递就会发生截断的情况，ACTION_DOWN经过Layout02的onInterceptTouchEvent时被强制直接交给自己的onTouchEvent继续传递。此时如果Layout01的onTouchEvent消费此事件： 图1.5 则后续事件就直接传递给Layout01的onTouchEvent处理了，如果让Layout02的dispatchTouchEvent直接返回true呢？ 图1.6 这种情况下ACTION_DOWN流经Layout02的dispatchTouchEvent时就很干脆的断了，后续事件在Layout02的dispatchTouchEvent就直接派发给自己的onTouchEvent处理，相当于Layout02在说：我不往下派发了，直接交给我来处理吧！ 还有些比较极端的情况：如果让Layout03的onTouchEvent来消费ACTION_DOWN事件，后续事件在流经Layout02的dispatchTouchEvent的时候就返回了true呢？ 图1.7 如图所示，后续事件在Layout02的dispatchTouchEvent就消失了，不再往下传递，Layout03也就接收不到ACTION_UP,ACTION_MOVE之类的后续事件了。最后，如果不在Layout02的dispatchTouchEvent返回true，而是在它的onInterceptTouchEvent返回呢？ 图1.8 这时候事件到达Layout02的onInterceptTouchEvent之后就变成了ACTION_CENCEL，直到传递给消费者。","categories":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/tags/Android/"}]},{"title":"Android Looper、Message、Handler、MessageQueue源码解析","slug":"Android-Looper、Message、Handler、MessageQueue源码解析","date":"2017-01-12T07:28:07.000Z","updated":"2021-02-14T14:01:43.638Z","comments":true,"path":"2017/01/12/ckl66lfqq0007wuz15r68alsj/","link":"","permalink":"https://dylantseng1915.github.io/2017/01/12/ckl66lfqq0007wuz15r68alsj/","excerpt":"","text":"在Android开发过程中，Message和Handler是经常会使用到的类，我们对它们广泛的认知是为了在异步任务中更新主线程的UI，因为在主线程处理耗时的任务是会ANR的。Message和Handler普遍使用的场景是HTTP请求，HTTP请求可能会造成长时间的线程阻塞，一般来说都是新开一个线程处理请求任务，在数据最终返回的时候调用Handler的handlerMessage方法，交给主线程处理，但是它们内部是如何运作的呢？为了搞清楚这个问题，我们先从ActivityThread这个main方法开始，一步一步分析： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 将目光聚焦在关键部分，在main方法里，首先调用Looper的静态方法prepareMainLooper，我们来看看prepareMainLooper干了些什么事？ 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; 都是一些静态调用，我们追踪下去 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; sThreadLocal这个静态变量是什么？它的声明和初始化是这样的： 1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); ThreadLocal这个类从字面意思就应该猜得出来，它可以保存本地线程变量，不受其他线程的干扰。那么，意思就很明确了，prepareMainLooper()方法首先检查本地变量是否保存有值，如果有，则抛异常退出，如果没有，就新建一个Looper实例，作为线程唯一副本保存在ThreadLocal之中，Looper在实例化时，初始化了一个MessageQueue对象，而这个MessageQueue对象，就是消息队列。剩下的sMainLooper = myLooper()很简单，就是将线程唯一Looper实例变量副本赋值给sMainLooper变量。接下来有一句神奇的代码： 123if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\"));&#125; 一脸懵逼 什么鬼？！！这句代码有什么特殊的考量吗？！！！我只能认为Google developer们调试后忘了删掉这段代码了 最后就调用Looper.loop()方法了，这个方法是重头戏！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 这块代码也很好理解，首先从本地线程也就是主线程取出保存在ThreadLocal里的Looper对实例，然后从Looper里取出MessageQueue实例，然后..然后…没错！你没有看错！！就开始死循环了…然后你会发现，**Android主线程就是一个死循环，这个死循环发生在Looper内部，你也可以认为Looper就是这个死循环，它不断的从MessageQueue取出Message，然后执行处理，最后回收Message**，Android的主线程就是这个简单，现在你也应该知道为什么我们必须要了解Looper、Message、Handler和MessageQueue，以及透彻他们的工作机制了吧。那么？Activity,Service,Intent,BroadcastReceiver的动作是如何最终变成Handler和Message的呢？这是一个大坑，以后再填，先抛下这个疑问，我们先看看这三个方法： 不断从MessageQueue取出Message的方法： 1Message msg = queue.next(); 执行处理Message的方法： 1msg.target.dispatchMessage(msg); 回收Message的方法： 1msg.recycleUnchecked(); 第一个方法比较复杂，我们先解析执行处理Message的方法msg.target.dispatchMessage(Message msg)。msg.target变量是个Handler对象，它从何而来呢？这个问题还得从我们发送一个Message开始说起。 通常我们发送一个Message是酱紫的： 123456789Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); // do something &#125;&#125;;Message message = handler.obtainMessage();handler.sendMessage(message); 进入Handler.obtainMessage()方法： 1234public final Message obtainMessage()&#123; return Message.obtain(this);&#125; Google Coder的开发人员有精神分裂么？这花括号… 再进入Message.obtain(Handler handler)方法： 123456public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h; return m;&#125; 好吧，原来target变量就是Handler.obtainMessage()这个Handler对象。那么，我们大致明白了，MessageQueue循环取出Message，每个Message都带着一个Handler，由Handler的dispatchMessage(Message msg)来处理该消息。辣么，Handler如何处理这个消息的呢？ 来看看dispatchMessage(Message msg)方法： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 从源码中可以看出最终执行的地方有三处，先后为：msg.callback, mCallback.handleMessage(msg)和handleMessage(msg)。handleMessage(msg)好理解，因为通常我们都是复写Handler的handleMessage(Message msg)来实现我们更新主线程UI的逻辑，另外两个就比较陌生了，我们一一解析。 msg.callback赋值的地方在两处： 123456789101112private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m;&#125; getPostMessage(Runnable r)和getPostMessage(Runnable r, Object token)这个两个方法又是分别在这些地方调用: 1234567891011121314151617181920public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125; 有没有熟悉的感觉？没错，这就是我们经常使用的发送更新主线程UI消息的一种方式： 123456new Handler().post(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;); post(Runnable r)、postAtTime(Runnable r, long uptimeMillis)、sendMessageDelayed(Message, delayMillis)……辣么多方法，会不会被搞晕了？ 一脸懵逼 我们用一张图来梳理一下这些方法 恩，这下清楚多了。 接下来搜索一下mCallback的出处，其实它是在Handler类的构造函数里被赋值的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Handler() &#123; this(null, false);&#125;public Handler(Callback callback) &#123; this(callback, false);&#125;public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;public Handler(boolean async) &#123; this(null, async);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 用图表梳理一下它们之间个关系： 从图中就很明显的看出7个构造方法分为两部分，一部分是默认使用本地线程的Looper对象，另一部分是需要传入一个Looper对象，两部分你都可以传入一个Callback回调，它的定义是在Handler类内部之中： 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 所以才会有mCallback.handleMessage(msg)的调用。所以你的Handler实例可以这样实例化： 123456new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; return false; &#125;&#125;); 跟 123456new Handler().post(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;); 其实是一个道理。 到目前为止，我们已经搞懂了消息是如何被处理的——它是由Handler三个部分：Runnable Callback，Callback Function以及Handler Default handleMessage Method其中之一处理的。现在我们回过头来看看消息是如何从MessageQueue取出来的，但首先我们得知道，Message是如何传入队列的。由上面发送消息方法的关系图可是知道，无论你是选择哪一种方式发送消息，最终它都会调用enqueueMessage(MessageQueue, Message, long)方法放入队列： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 再进入MessageQueue的enqueueMessage(Message, long)方法看看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 代码有点长，我们从msg.when = when这一段开始读起，第一个问题就来了，mMessage是干什么的？它的变量声明其实是个Message对象，它有什么作用呢？往下看，有个注释暗示了它的作用——New head, wake up the event queue if blocked.**意思就不言而喻了，mMessage就是MessageQueue消息队列的队列头**，往下看接下来的判断语句： 123456if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; 首先我们得知道，每个Message都是有自己的处理时间的——when属性，这个when属性决定了这个Message在MessageQueue的位置(Message是根据when来排列的)以及处理的规定时间点，但是有种Message例外，它的when属性是0，由Handler.sendMessageAtFrontOfQueue(Message)发送，从这个方法的命名就可以知道它的意图——希望这个Message排在队列的头部，也就是希望这个消息能够立刻处理。那么这个判断语句我们也应该知道它的意思了：如果队列头为空或者when为0或者需要处理的时间比队头的时间还要紧迫，则将这个Message作为新的队头。 enqueue MessageQueue header 00 enqueue MessageQueue header 01 enqueue MessageQueue header 02 再看看else语句，图我也不画了，意思也简单，从队头往后遍历Message，根据when值将新的Message插入到合适的位置。 看完了MessageQueue.enqueueMessage(Message, long)方法，我们可以探讨一下Message是如何从MessageQueue取出来的了，看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); // 阻塞的时间可能很长,确保在此期间释放渲染对象的引用,以免占用空间 &#125; nativePollOnce(ptr, nextPollTimeoutMillis); // 轮询, 阻塞 synchronized (this) &#123; // 尝试检索下一个Message final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. // msg.target为空的情况我不知道, do-while语句是寻找下一个可异步执行的Message do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一个Message的可执行时间点未到, 这个Message有两种,一个是队头Message, 另一个是下一个可异步执行的Message nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 得到一个Message,如果是得到可异步执行的Message, prevMsg.next -&gt; msg.next, return msg // 如果是表头,将mMessage指向下一个Message, return msg mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ... &#125; ... &#125;&#125; 无关（看不懂的）的代码我用省略号代替了，关键部分的代码的意思我写在注释中。到这里，MessageQueue如何去除Message的也已经讲解完了，说白了，就是一个队列的运用而已。最后，打起精神，咬下最后一根硬骨头，Message.recycleUnchecked() 1234567891011121314151617181920212223void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 这个方法很简单，只是一些清空数据的代码而已，但是注意到一个静态变量没有——sPool，这是什么东西？它的变量声明也是一个Message对象，它是用来干什么的呢？解答疑惑的地方在Message的静态方法obtain里： 12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 不管是Handler.obtainMessage方法，还是Message另外几个obtain方法，最终都会通过调用Message.obtain()这个无参静态方法，它的代码也告诉了我们sPool的作用，它相当于指向一个栈的栈顶，每次使用后的Message实例都会压入这个栈中，每次使用或间接使用Message.obtain()方法都会从栈中弹出一个Message实例，以便做到循环使用，如果不这样子，这个栈就会无限增加Message实例，造成内存泄露，甚至内存溢出，这一点在开发的时候要注意。 最后我们总结一下研究成果： Looper: 它是整个运作的场景，它在主线程中有唯一实例，它内部有唯一的消息队列，由它对整个运作进行初始化，并且调用loop()方法开始循环从消息队列中取消息，处理消息，回收消息。 MessageQueue: 它相当于一个队列容器，由它接收新的消息，在接收的时候会依照消息指定的处理时间点适当的插入到队列中，在取出的时候可能会因为下一个消息的时间点未到而阻塞。 Message: 它是一个消息，它由指定处理时间点、辅助处理的数据以及处理对象等元素组成。 Handler: 它是某个消息的消息处理者，它处理消息的方式有三种，但只能是其中之一处理，它们依次是Runnable的run()方法，Handler的内部类Callback的handleMessage(Message)方法以及Handler的默认方法handleMessage(Message)","categories":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/tags/Android/"},{"name":"Looper","slug":"Looper","permalink":"https://dylantseng1915.github.io/tags/Looper/"},{"name":"Message","slug":"Message","permalink":"https://dylantseng1915.github.io/tags/Message/"},{"name":"Handler","slug":"Handler","permalink":"https://dylantseng1915.github.io/tags/Handler/"},{"name":"MessageQueue","slug":"MessageQueue","permalink":"https://dylantseng1915.github.io/tags/MessageQueue/"}]},{"title":"聊聊Android Theme的那些事","slug":"聊聊Android-Theme的那些事","date":"2017-01-12T07:26:50.000Z","updated":"2021-02-14T14:01:43.639Z","comments":true,"path":"2017/01/12/ckl66lfqk0002wuz1bgp1fhqp/","link":"","permalink":"https://dylantseng1915.github.io/2017/01/12/ckl66lfqk0002wuz1bgp1fhqp/","excerpt":"","text":"1. 概述话说Android里面的主题真是琳琅满目，虽然平时开发时我们都是固定，约定成熟的使用某个主题，例如官方推荐的AppComat系列，但是Android有多少主题，它们之间有什么联系和区别很少人去认真探究。我本人开发时都是直接使用Android Studio生成的主题，或者是继承至它。Holo主题基本没有使用过，似乎是一个比较老的主题，比我早接触Android的前辈们应该比较熟悉。Material主题就属于比较新的主题。还有呢？ 2. 一些主要的根主题以及它的继承结构这里我使用了“根主题”的说法，因为大多数主题都是继承至某个主题，追根究底，会找到几个没有parent的根主题。我们来看看这几个根主题： Theme：API 10及其以下的默认主题。 Theme.Holo：API 11 - 13的默认主题， Theme.Material：API 21及其以上。 2.1 如何追溯到这些Theme？你可以随便新建一个Theme，parent继承至Theme.AppCompat，按住Ctrl(在Mac上是Command)点击parent主题，这样一直追溯到Platform.AppComat会有几个选择： platform version list 到这里，Theme的继承就区别开来了，/values.xml最终会继承至Theme，/values-v11.xml和/values-v14.xml最终会继承至Theme.Holo，而/values-v21.xml会继承至Theme.Material。所以说，一般我们选择主题选择继承至AppCompat系列的主题就可以了(至少现在是如此)，AppCompat已经做好适配工作了。 2.2 它们有什么区别呢?据我所对比观察，它们的参数基本上相同： Theme diff 双方有些细微的增缺，只有值大不一样，但这并不影响什么，我们必要的时候直接去所关心的Theme那里了解一下目标参数。一个主题规范严格的app，风格的定义应该在App Theme上就得到了统一，这些根主题的参数给了我们修改，参考的依据，了解这些参数是很有必要的。 2.3 只有这些根主题吗?当然，Android系统如此庞杂，远远不止这些根主题，上述3个根主题所在的xml文件里定义了很多根主题，适当了解一下会有好处。 2.4 如此多的子主题，我们该如何抉择？看看它的继承结构。我先贴上一张自己总结的图： theme construction 我以AppCompat系列的主题为例，图中并没有将所有主题都收拢进去，毕竟太多了。图中枝节点的依据是这样子：例如Base.TextAppearance.AppCompat.Widget.Actionbar.Subtitle.Inverse这个style，已.为分割线，Base、TextAppearance…为节点作成的结构图。从图中可以很直观的得出结论：主题分为TextAppearance、Theme、ThemeOverlay和Widget4种。 TextAppeareance: 定义字体样式。 Theme: 定义Dialog和Application的样式。 ThemeOverlay: 定义悬浮层的样式，例如点击ActionBar上的更多或者下拉菜单弹出的悬浮界面的样式。 Widget：顾名思义，定义Button之类的组件的样式。 如果你想使用某个字体主题或者自定义，你可以使用或者继承TextAppearance系列： TextAppearance Theme 同样的Theme系列： Theme Theme ThemeOverlay系列： ThemeOverlay Theme Widget系列： Widget Theme Android的Style命名已经极大的便利我们使用，我们唯一要做的事就是根据业务需求了解某个主题的参数和值，并且在必要的时候复写它。 3 自定义样式现在用实际行动来验证我们的猜想。我新建了一个Activity，它是这样子： origin Activity代码： 1234567891011121314151617181920212223242526272829public class ActionBarActivity extends AppCompatActivity &#123; @Bind(R.id.toolbar) Toolbar mToolbar; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_action_bar); ButterKnife.bind(this); mToolbar.setTitle(\"Thanatosx\"); mToolbar.setSubtitle(\"Widgets\"); setSupportActionBar(mToolbar); ActionBar mActionBar = getSupportActionBar(); if (mActionBar != null)&#123; mActionBar.setDisplayHomeAsUpEnabled(true); mActionBar.setHomeButtonEnabled(false); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menus, menu); return super.onCreateOptionsMenu(menu); &#125;&#125; Layout布局文件： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:background=\"#80123456\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/LinearLayout&gt; 以及Theme主题： 1234567&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;&lt;/style&gt; 现在我们想要通过修改Theme来改变Toolbar的样式达到以下效果： 改变返回图标 改变Title和Subtitle的字体大小和颜色 改变more icon的颜色 首先，第一个问题是：去哪里修改？前面说到，Theme主题基本可以定义一个Application的大部分地方的样式，我们需要去搜索一下父主题是否有这样的定义，从Theme.AppCompat.Light这个主题开始往上追溯，在Base.Theme.AppCompat.Light上会有个版本选择： show version list 这个无所谓，选择低版本的就可以了，低版本都支持的话就不用担心高版本，首先会在Base.v7.Theme.AppCompat.Light上发现Toolbar Style的定义： found out toolbar style 那么，我们就可以复写这个属性，自定义我们的Toolbar Style了，同样的，有个actionOverflowButtonStyle属性，它就是定义more icon button的属性了。 修改后的Theme： 12345678910111213141516171819202122232425262728293031&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"actionOverflowButtonStyle\"&gt;@style/AppWidget.ActionButton.Overflow&lt;/item&gt; &lt;item name=\"toolbarStyle\"&gt;@style/AppTheme.Toolbar&lt;/item&gt;&lt;/style&gt;&lt;style name=\"AppTheme.Toolbar\" parent=\"Widget.AppCompat.Toolbar\"&gt; &lt;item name=\"android:minHeight\"&gt;50dp&lt;/item&gt; &lt;item name=\"titleTextAppearance\"&gt;@style/AppTextAppearance.Widget.Actionbar.Title&lt;/item&gt; &lt;item name=\"subtitleTextAppearance\"&gt;@style/AppTextAppearance.Widget.Actionbar.Subtitle&lt;/item&gt; &lt;item name=\"navigationIcon\"&gt;@mipmap/ic_back&lt;/item&gt; &lt;item name=\"android:background\"&gt;?attr/colorPrimary&lt;/item&gt;&lt;/style&gt;&lt;style name=\"AppTextAppearance.Widget.Actionbar.Title\" parent=\"TextAppearance.Widget.AppCompat.Toolbar.Title\"&gt; &lt;item name=\"android:textSize\"&gt;14sp&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;#FFF&lt;/item&gt;&lt;/style&gt;&lt;style name=\"AppTextAppearance.Widget.Actionbar.Subtitle\" parent=\"TextAppearance.Widget.AppCompat.Toolbar.Subtitle\"&gt; &lt;item name=\"android:textSize\"&gt;12sp&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;#FFF&lt;/item&gt;&lt;/style&gt;&lt;style name=\"AppWidget.ActionButton.Overflow\" parent=\"Widget.AppCompat.ActionButton.Overflow\"&gt; &lt;item name=\"android:src\"&gt;@mipmap/ic_more&lt;/item&gt;&lt;/style&gt; parent继承至原使用的Style Theme，以此基础上重写自己需要修改的属性，最终效果图： 4 坑在修改Activity的返回按钮的时候我在AppTheme里找到这个属性：homeAsUpIndicator，老司机们肯定明白，这就是设置返回按钮的图标，但是无论我如何设置，修改，这个属性没有任何效果！！无奈之下，我去overflowstack上寻找答案，众说纷纭，倒是看到这个属性navigationIcon，我在Theme上没看到，在Toolbar的主题上也没有看到，但是当我进入Toolbar的源码，我发现是有这个属性的： 我直接跑去R.java文件去看，一目了然： r.java 源码之下，没有秘密 还有一点，设置navigationIcon之后，点击返回按钮没有任何响应了，需要设置Navigation Click Listener 1234567// after set support action barmToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/tags/Android/"},{"name":"Theme","slug":"Theme","permalink":"https://dylantseng1915.github.io/tags/Theme/"}]},{"title":"FragmentPagerAdapter与FragmentStatePagerAdapter的差异","slug":"FragmentPagerAdapter与FragmentStatePagerAdapter的差异","date":"2017-01-12T07:23:55.000Z","updated":"2021-02-14T14:01:43.638Z","comments":true,"path":"2017/01/12/ckl66lfre000ywuz1de5a5cp6/","link":"","permalink":"https://dylantseng1915.github.io/2017/01/12/ckl66lfre000ywuz1de5a5cp6/","excerpt":"","text":"1、概述PagerAdapter是提供计算ViewPager内的Pages的适配器，而FragmentPagerAdapter与FragmentStatePagerAdapter都是继承至PagerAdapter这个基类，是PagerAdapter的两个特殊实现。可能有些人会断章取义的认为FragmentPagerAdapter不会保存Fragment的状态，而FragmentStatePagerAdapter会维持Fragment的状态。事实上，这是一种错误的理解，虽然你在使用时并不会有什么影响。FragmentPagerAdapter与FragmentStatePagerAdapter的实现跟它们所要服务的场景有密切的关系，我们通过理解二者的源码来了解设计者的设计目的。 2、FragmentPagerAdapter首先先贴上源代码，代码量不是很多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public abstract class FragmentPagerAdapter extends PagerAdapter &#123; private static final String TAG = \"FragmentPagerAdapter\"; private static final boolean DEBUG = false; private final FragmentManager mFragmentManager; private FragmentTransaction mCurTransaction = null; private Fragment mCurrentPrimaryItem = null; public FragmentPagerAdapter(FragmentManager fm) &#123; mFragmentManager = fm; &#125; /** * Return the Fragment associated with a specified position. */ public abstract Fragment getItem(int position); @Override public void startUpdate(ViewGroup container) &#123; if (container.getId() == View.NO_ID) &#123; throw new IllegalStateException(\"ViewPager with adapter \" + this + \" requires a view id\"); &#125; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) &#123; if (DEBUG) Log.v(TAG, \"Attaching item #\" + itemId + \": f=\" + fragment); mCurTransaction.attach(fragment); &#125; else &#123; fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + itemId + \": f=\" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); &#125; if (fragment != mCurrentPrimaryItem) &#123; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); &#125; return fragment; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, \"Detaching item #\" + getItemId(position) + \": f=\" + object + \" v=\" + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object); &#125; @Override public void setPrimaryItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment)object; if (fragment != mCurrentPrimaryItem) &#123; if (mCurrentPrimaryItem != null) &#123; mCurrentPrimaryItem.setMenuVisibility(false); mCurrentPrimaryItem.setUserVisibleHint(false); &#125; if (fragment != null) &#123; fragment.setMenuVisibility(true); fragment.setUserVisibleHint(true); &#125; mCurrentPrimaryItem = fragment; &#125; &#125; @Override public void finishUpdate(ViewGroup container) &#123; if (mCurTransaction != null) &#123; mCurTransaction.commitNowAllowingStateLoss(); mCurTransaction = null; &#125; &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return ((Fragment)object).getView() == view; &#125; @Override public Parcelable saveState() &#123; return null; &#125; @Override public void restoreState(Parcelable state, ClassLoader loader) &#123; &#125; /** * Return a unique identifier for the item at the given position. * * &lt;p&gt;The default implementation returns the given position. * Subclasses should override this method if the positions of items can change.&lt;/p&gt; * * @param position Position within this adapter * @return Unique identifier for the item at position */ public long getItemId(int position) &#123; return position; &#125; private static String makeFragmentName(int viewId, long id) &#123; return \"android:switcher:\" + viewId + \":\" + id; &#125;&#125; 我们把目光聚焦到这几个主要的方法： public Object instantiateItem(ViewGroup container, int position) public void destroyItem(ViewGroup container, int position, Object object) public void finishUpdate(ViewGroup container) public Parcelable saveState() public void restoreState(Parcelable state, ClassLoader loader) 方法saveState和restoreState并没有干什么事情，但是在FragmentStatePagerAdapter中就大不一样，所以现在先注意这两个方法。finishUpdate当已显示的pages完成改变后调用，一般在这个方法内commit FragmentTransaction的操作。我们首先看看instantiateItem方法的源代码，它是用来实例化某个item的： 123456789101112131415161718192021222324252627 @Overridepublic Object instantiateItem(ViewGroup container, int position) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) &#123; if (DEBUG) Log.v(TAG, \"Attaching item #\" + itemId + \": f=\" + fragment); mCurTransaction.attach(fragment); &#125; else &#123; fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + itemId + \": f=\" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); &#125; if (fragment != mCurrentPrimaryItem) &#123; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); &#125; return fragment;&#125; 这个方法首先获得一个itemId（实际上返回时的position本身），然后作为参数传入makeFragmentName方法生成一个name，然后使用这个name在FragmentManager内搜索出Fragment，如果不为空，说明以前加入过，那么重新attach这个Fragment，如果为空，那么使用getItem创建一个，getItem就是需要我们自己实现的抽象方法之一，最后将新创建的Fragment add进去。 既然FragmentPagerAdapter实例化item得方式是通过add或者attach，那么，显而易见，在destroyItem内必定是使用detach来‘卸载’item： 123456789 @Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, \"Detaching item #\" + getItemId(position) + \": f=\" + object + \" v=\" + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object);&#125; 果然，很简单的操作，使用FragmentTransaction attach了需要销毁的Fragment。 FragmentPagerAdapter整个流程很简单，就是 add -&gt; detach -&gt; attach -&gt; detach -&gt; …因为走的是detach和attach的路，所以系统会保存Fragment的State。FragmentPagerAdapter是很普通的一个PagerAdapter的实现类，适用于基本的使用场景，但是如果是有大量的Tab的使用场景，FragmentPagerAdapter就不太适用了，因为它的状态都用系统保存常驻在内存之中了，并且Fragment的实例也常驻在内存，所以会导致大量的内存占用。 FragmentStatePagerAdapter就解决FragmentPagerAdapter短板的问题。 3、FragmentStatePagerAdapterFragmentStatePagerAdapter相对FragmentPagerAdapter多了两个变量： 12private ArrayList&lt;Fragment.SavedState&gt; mSavedState = new ArrayList&lt;Fragment.SavedState&gt;();private ArrayList&lt;Fragment&gt; mFragments = new ArrayList&lt;Fragment&gt;(); 意图很明显了，mFragments用来保存Fragment的实例，mSavedState用来保存每个Fragment的状态，我们接下来看看instantiateItem和destroyItem这两个方法： 1234567891011121314151617181920212223242526272829303132333435@Overridepublic Object instantiateItem(ViewGroup container, int position) &#123; // If we already have this item instantiated, there is nothing // to do. This can happen when we are restoring the entire pager // from its saved state, where the fragment manager has already // taken care of restoring the fragments we previously had instantiated. if (mFragments.size() &gt; position) &#123; Fragment f = mFragments.get(position); if (f != null) &#123; return f; &#125; &#125; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; Fragment fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + position + \": f=\" + fragment); if (mSavedState.size() &gt; position) &#123; Fragment.SavedState fss = mSavedState.get(position); if (fss != null) &#123; fragment.setInitialSavedState(fss); &#125; &#125; while (mFragments.size() &lt;= position) &#123; mFragments.add(null); &#125; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); mFragments.set(position, fragment); mCurTransaction.add(container.getId(), fragment); return fragment;&#125; FragmentStatePagerAdapter首先会在mFragments集合内寻找对应position的Fragment，如果position大于该集合的size，说明该position下的Fragment从未被访问过，那么就会执行getItem创建新的实例。如果position在mSavedState集合范围内，说明改Fragment曾经访问过，并且有它以前的状态，那么，还原这个状态。最后加入FragmentManager之中。再来看看destroyItem方法： 123456789101112131415161718@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, \"Removing item #\" + position + \": f=\" + object + \" v=\" + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); mCurTransaction.remove(fragment);&#125; 不同于FragmentPagerAdapter，FragmentStatePagerAdapter是采用remove的方式销毁Fragment，但实际上，活动的Fragment实例保存在mFragments之中，在destroyItem方法内又会被移除，但是状态不会被删除，总是保存在mSavedState集合之中。所以，FragmentStatePagerAdapter的机制是: add -&gt; save state -&gt; remove -&gt; initial state -&gt; add -&gt; … 这里有也暴露了FragmentStatePagerAdapter两个致命的问题：一是状态不会被删除，总是保存在mSavedState集合中，如果一个ViewPager像网易新闻那样有几十个Tab，势必会造成内存压力。二是不能做移除Tab的工作，即使你移除的某个Tab以及相关的Fragment，状态依然没有删除，我们又不能删除，没有相关的API，同时，例如你删除了position为2的Fragment,原本position为3的Fragment就会使用position为2的Fragment的状态。这是很致命的问题。 4、区别在哪？FragmentPagerAdapter和FragmentStatePagerAdapter的机制决定了它们的区别。FragmentPagerAdapter使用add, attach, detach来管理Fragment，Fragment实例和状态都被保存下来，但是重建的消耗不高，生命周期在onAttach和onDetach间游走，典型的用内存换效率的做法。而FragmentStatePagerAdapter使用add, remove来管理Fragment，被销毁的Fragment实例不再存在，但是其状态保存在集合之中，以便下次重新创建实例时能够还原之前的状态。","categories":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://dylantseng1915.github.io/tags/Android/"},{"name":"ViewPager","slug":"ViewPager","permalink":"https://dylantseng1915.github.io/tags/ViewPager/"},{"name":"Adapter","slug":"Adapter","permalink":"https://dylantseng1915.github.io/tags/Adapter/"}]},{"title":"基本排序(C语言版)","slug":"基本排序(C语言版)","date":"2017-01-12T06:47:03.000Z","updated":"2021-02-14T14:01:43.639Z","comments":true,"path":"2017/01/12/ckl66lfqf0000wuz1f3yh6un8/","link":"","permalink":"https://dylantseng1915.github.io/2017/01/12/ckl66lfqf0000wuz1f3yh6un8/","excerpt":"","text":"冒泡排序12345678910111213141516/*** 冒泡排序 logN^2* 基本思路：每次从数组底端将最小的数“冒”上来* **/void BubbleSort(int *p, int len)&#123; for(int i=0; i&lt;len-1; i++)&#123; for(int j=len-1; j&gt;i; j--)&#123; if(*(p+j)&lt;*(p+j-1))&#123; *(p+j) ^= *(p+j-1); *(p+j-1) ^= *(p+j); *(p+j) ^= *(p+j-1); &#125; &#125; &#125;&#125; 选择排序12345678910111213141516/*** 选择排序 logN^2**/void SelectSort(int *p, int len)&#123; for(int i=0; i&lt;len-1; i++)&#123; int min = i; for(int j=len-1; j&gt;i; j--)&#123; if(*(p+j)&lt;*(p+min)) min = j; &#125; if(min != i)&#123; *(p+i) ^= *(p+min); *(p+min) ^= *(p+i); *(p+i) ^= *(p+min); &#125; &#125;&#125; 插入排序1234567891011121314/*** 插入排序 logN^2**/void InsertSort(int *p, int len)&#123; for(int i=0; i&lt;len-1; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; if(*(p+j)&lt;*(p+j-1))&#123; *(p+j) ^= *(p+j-1); *(p+j-1) ^= *(p+j); *(p+j) ^= *(p+j-1); &#125;else break; &#125; &#125; &#125; 希尔排序1234567891011121314151617181920/*** 希尔排序 N^1.5* 基本思路：选取某个增量，将数组分为若干的子序列，对子序列进行插入排序，* 逐渐减小增量，重复上述操作，直到增量为1，此时数组基本有序，最后进行一次插入排序。**/void ShellSort(int *p, int len)&#123; for(int incre=len/2; incre&gt;=1; incre--)&#123; for(int i=0; i&lt;incre; i++)&#123; for(int j=i+incre; j&lt;len; j+=incre)&#123; for(int k=j; k&gt;i; k-=incre)&#123; if(*(p+k)&lt;*(p+k-incre))&#123; *(p+k) ^= *(p+k-incre); *(p+k-incre) ^= *(p+k); *(p+k) ^= *(p+k-incre); &#125;else break; &#125; &#125; &#125; &#125;&#125; 快速排序123456789101112131415161718/*** 快速排序 N*logN**/void QuickSort(int *p, int len)&#123; if(len&lt;=1) return; int *b = p; int *e = p + len - 1; int sentry = *p; while(b&lt;e)&#123; while(b&lt;e &amp;&amp; *e &gt;= sentry) e--; *b = *e; while(b&lt;e &amp;&amp; *b &lt;= sentry) b++; *e = *b; &#125; *b = sentry; QuickSort(p, b-p); QuickSort(b+1, len-(b-p)-1);&#125; 归并排序1234567891011121314151617181920212223242526272829/*** 归并排序 N*logN* 需要额外的空间存放数据* 基本思想：将一个数组分成两份，如果这两份数组的有序的，那么将这两份数组归并，* 对上述操作进行递归操作，直到分成的数组仅仅只有一个元素，那么它理所当然是有序的。**/void MergeArray(int *p, int len1, int *q, int len2)&#123; int temp[len1+len2]; int i,j,k; i = j = k = 0; while(i&lt;len1 &amp;&amp; j&lt;len2)&#123; if(*(p+i)&lt;*(q+j))&#123; temp[k++] = *(p+i++); &#125;else&#123; temp[k++] = *(q+j++); &#125; &#125; while(i&lt;len1) temp[k++] = *(p+i++); while(j&lt;len2) temp[k++] = *(q+j++); for(i=0; i&lt;len1+len2; i++) *(p+i) = temp[i];&#125;void MergeSort(int *p, int len)&#123; if(len&lt;=1) return; int middle = len/2; MergeSort(p, middle); MergeSort(p+middle, len-middle); MergeArray(p, middle, p+middle, len-middle);&#125; 堆排序1234567891011121314151617181920212223242526272829303132/*** 堆排序 N * logN* len/2 -1 最后一个节点的父节点* 2*i + 1 左孩子节点* 2*i + 2 右孩子节点* 基本思路：将一个数组看作是完全二叉树，先调整整个堆，然后将根节点和* 末节点互换，重新调整堆**/void HeapAdjust(int *p, int len, int i)&#123; int child = 2*i+1; if(child&gt;=len) return; if(child&lt;len-1 &amp;&amp; *(p+child)&lt;*(p+child+1)) child++; if(*(p+i)&lt;*(p+child))&#123; *(p+i) ^= *(p+child); *(p+child) ^= *(p+i); *(p+i) ^= *(p+child); HeapAdjust(p, len, child); &#125; &#125;void HeapSort(int *p, int len)&#123; //首先先从最后一个节点的父节点开始调整堆 for(int i=len/2-1; i&gt;=0; i--) HeapAdjust(p, len, i); for(int i=len-1; i&gt;0; i--)&#123; *p ^= *(p+i); *(p+i) ^= *p; *p ^= *(p+i); HeapAdjust(p, i, 0); // &lt;--not i+1 &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://dylantseng1915.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://dylantseng1915.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","permalink":"https://dylantseng1915.github.io/tags/%E7%AE%97%E6%B3%95/"}]}]}