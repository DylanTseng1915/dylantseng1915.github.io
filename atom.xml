<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dylan Tseng 的博客</title>
  
  
  <link href="https://dylantseng.github.io/atom.xml" rel="self"/>
  
  <link href="https://dylantseng.github.io/"/>
  <updated>2021-02-14T14:01:43.639Z</updated>
  <id>https://dylantseng.github.io/</id>
  
  <author>
    <name>Dylan Tseng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解Android触摸事件处理程序</title>
    <link href="https://dylantseng.github.io/2017/01/12/ckl5e1azb00046dz12fhi2w6z/"/>
    <id>https://dylantseng.github.io/2017/01/12/ckl5e1azb00046dz12fhi2w6z/</id>
    <published>2017-01-12T07:30:16.000Z</published>
    <updated>2021-02-14T14:01:43.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="详解Android触摸事件处理程序"><a href="#详解Android触摸事件处理程序" class="headerlink" title="详解Android触摸事件处理程序"></a>详解Android触摸事件处理程序</h3><p>在了解触摸时间处理程序之前，我们来了解这几个主角：</p><ul><li><code>dispatchTouchEvent(MotionEvent ev)</code>：此方法允许 ViewGroup 在分派之前截获所有触摸事件</li><li><code>onInterceptTouchEvent(MotionEvent ev)</code>：此方法允许 ViewGroup 监视分派给子视图的事件</li><li><code>onTouchEvent(MotionEvent ev)</code>： 在发生触摸屏运动事件时调用</li></ul><p>接下来展示一下工作界面，注意，<code>Layout03</code>是嵌套在<code>Layout02</code>里面的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram00.png" alt="图1.1布局文件" title="">                </div>                <div class="image-caption">图1.1布局文件</div>            </figure><p>首先，按下<code>Layout03</code>，事件流程如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram01.png" alt="图1.2" title="">                </div>                <div class="image-caption">图1.2</div>            </figure><p>按下的时候总共有触发两个事件：<code>ACTION_DOWN</code>和<code>ACTION_UP</code>，但是因为整个事件流程中并没有哪个组件消费了<code>ACTION_DOWN</code>事件，而<strong>只有在<code>onTouchEvent</code>中消费了<code>ACTION_DOWN</code>事件，后续事件<code>ACTION_UP</code>,<code>ACTION_MOVE</code>…才会触发</strong>，所以这里<code>ACTION_DOWN</code>事件一路挥歌直下，<code>ACTION_UP</code>则并没有发生。</p><p>我们让<code>Layout02</code>的<code>onTouchEvent</code>返回<code>true</code>，消费<code>ACTION_DOWN</code>事件，事件流程如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram03.png" alt="图1.3" title="">                </div>                <div class="image-caption">图1.3</div>            </figure><p>可以看到<code>Layout02</code>的<code>onTouchEvent</code>消费<code>ACTION_DOWN</code>事件之后便不在往下传了，后续事件也随后开始出现，并且<code>Layout02</code>直接将后续事件派发给消费者。所以<strong>当一个组件消费了<code>ACTION_DOWN</code>事件时，后续事件从窗口传到该组件的<code>dispatchTouchEvent</code>之后便直接交给它的<code>onTouchEvent</code>方法处理</strong></p><p>我们在<code>Layout02</code>的<code>onInterceptTouchEvent</code>里返回<code>true</code>，事件流程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram04.png" alt="图1.4" title="">                </div>                <div class="image-caption">图1.4</div>            </figure><p>这时候事件传递就会发生<strong>截断</strong>的情况，<code>ACTION_DOWN</code>经过<code>Layout02</code>的<code>onInterceptTouchEvent</code>时被强制直接交给自己的<code>onTouchEvent</code>继续传递。此时如果<code>Layout01</code>的<code>onTouchEvent</code>消费此事件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram05.png" alt="图1.5" title="">                </div>                <div class="image-caption">图1.5</div>            </figure><p>则后续事件就直接传递给<code>Layout01</code>的<code>onTouchEvent</code>处理了，如果让<code>Layout02</code>的<code>dispatchTouchEvent</code>直接返回<code>true</code>呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram06.png" alt="图1.6" title="">                </div>                <div class="image-caption">图1.6</div>            </figure><p>这种情况下<code>ACTION_DOWN</code>流经<code>Layout02</code>的<code>dispatchTouchEvent</code>时就很干脆的断了，后续事件在<code>Layout02</code>的<code>dispatchTouchEvent</code>就直接派发给自己的<code>onTouchEvent</code>处理，相当于<code>Layout02</code>在说：我不往下派发了，直接交给我来处理吧！</p><p>还有些比较极端的情况：如果让<code>Layout03</code>的<code>onTouchEvent</code>来消费<code>ACTION_DOWN</code>事件，后续事件在流经<code>Layout02</code>的<code>dispatchTouchEvent</code>的时候就返回了<code>true</code>呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram07.png" alt="图1.7" title="">                </div>                <div class="image-caption">图1.7</div>            </figure><p>如图所示，后续事件在<code>Layout02</code>的<code>dispatchTouchEvent</code>就消失了，不再往下传递，<code>Layout03</code>也就接收不到<code>ACTION_UP</code>,<code>ACTION_MOVE</code>之类的后续事件了。最后，如果不在<code>Layout02</code>的<code>dispatchTouchEvent</code>返回<code>true</code>，而是在它的<code>onInterceptTouchEvent</code>返回呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/touch_progress/TouchProgram08.png" alt="图1.8" title="">                </div>                <div class="image-caption">图1.8</div>            </figure><p>这时候事件到达<code>Layout02</code>的<code>onInterceptTouchEvent</code>之后就变成了<code>ACTION_CENCEL</code>，直到传递给消费者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;详解Android触摸事件处理程序&quot;&gt;&lt;a href=&quot;#详解Android触摸事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;详解Android触摸事件处理程序&quot;&gt;&lt;/a&gt;详解Android触摸事件处理程序&lt;/h3&gt;&lt;p&gt;在了解触摸时间处理程</summary>
      
    
    
    
    <category term="Android" scheme="https://dylantseng.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://dylantseng.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Looper、Message、Handler、MessageQueue源码解析</title>
    <link href="https://dylantseng.github.io/2017/01/12/ckl5e1aze00086dz1acxa892t/"/>
    <id>https://dylantseng.github.io/2017/01/12/ckl5e1aze00086dz1acxa892t/</id>
    <published>2017-01-12T07:28:07.000Z</published>
    <updated>2021-02-14T14:01:43.638Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发过程中，<code>Message</code>和<code>Handler</code>是经常会使用到的类，我们对它们广泛的认知是为了在异步任务中更新主线程的UI，因为在主线程处理耗时的任务是会ANR的。<code>Message</code>和<code>Handler</code>普遍使用的场景是HTTP请求，HTTP请求可能会造成长时间的线程阻塞，一般来说都是新开一个线程处理请求任务，在数据最终返回的时候调用<code>Handler</code>的<code>handlerMessage</code>方法，交给主线程处理，但是它们内部是如何运作的呢？<br>为了搞清楚这个问题，我们先从<code>ActivityThread</code>这个<code>main</code>方法开始，一步一步分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    AndroidKeyStoreProvider.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将目光聚焦在关键部分，在<code>main</code>方法里，首先调用<code>Looper</code>的静态方法<code>prepareMainLooper</code>，我们来看看<code>prepareMainLooper</code>干了些什么事？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是一些静态调用，我们追踪下去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sThreadLocal</code>这个静态变量是什么？它的声明和初始化是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>这个类从字面意思就应该猜得出来，它可以保存本地线程变量，不受其他线程的干扰。那么，意思就很明确了，<code>prepareMainLooper()</code>方法首先检查本地变量是否保存有值，如果有，则抛异常退出，如果没有，就新建一个<code>Looper</code>实例，作为线程唯一副本保存在<code>ThreadLocal</code>之中，<code>Looper</code>在实例化时，初始化了一个<code>MessageQueue</code>对象，而这个<code>MessageQueue</code>对象，就是消息队列。<br>剩下的<code>sMainLooper = myLooper()</code>很简单，就是将线程唯一<code>Looper</code>实例变量副本赋值给<code>sMainLooper</code>变量。<br>接下来有一句神奇的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">    Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/001.jpg" alt="一脸懵逼" title="">                </div>                <div class="image-caption">一脸懵逼</div>            </figure><p>什么鬼？！！<br>这句代码有什么特殊的考量吗？！！！<br>我只能认为Google developer们调试后忘了删掉这段代码了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/002.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后就调用<code>Looper.loop()</code>方法了，这个方法是重头戏！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码也很好理解，首先从本地线程也就是主线程取出保存在<code>ThreadLocal</code>里的<code>Looper</code>对实例，然后从<code>Looper</code>里取出<code>MessageQueue</code>实例，然后..然后…没错！你没有看错！！就开始死循环了…然后你会发现，**Android主线程就是一个死循环，这个死循环发生在<code>Looper</code>内部，你也可以认为<code>Looper</code>就是这个死循环，它不断的从<code>MessageQueue</code>取出<code>Message</code>，然后执行处理，最后回收<code>Message</code>**，Android的主线程就是这个简单，现在你也应该知道为什么我们必须要了解Looper、Message、Handler和MessageQueue，以及透彻他们的工作机制了吧。那么？<code>Activity</code>,<code>Service</code>,<code>Intent</code>,<code>BroadcastReceiver</code>的动作是如何最终变成<code>Handler</code>和<code>Message</code>的呢？这是一个大坑，以后再填，先抛下这个疑问，我们先看看这三个方法：</p><p>不断从<code>MessageQueue</code>取出<code>Message</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message msg = queue.next();</span><br></pre></td></tr></table></figure><p>执行处理<code>Message</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure><p>回收<code>Message</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.recycleUnchecked();</span><br></pre></td></tr></table></figure><p>第一个方法比较复杂，我们先解析执行处理<code>Message</code>的方法<code>msg.target.dispatchMessage(Message msg)</code>。<code>msg.target</code>变量是个<code>Handler</code>对象，它从何而来呢？这个问题还得从我们发送一个<code>Message</code>开始说起。</p><p>通常我们发送一个<code>Message</code>是酱紫的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Message message = handler.obtainMessage();</span><br><span class="line">handler.sendMessage(message);</span><br></pre></td></tr></table></figure><p>进入<code>Handler.obtainMessage()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Google Coder的开发人员有精神分裂么？这花括号…</p><p>再进入<code>Message.obtain(Handler handler)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，原来target变量就是<code>Handler.obtainMessage()</code>这个<code>Handler</code>对象。那么，我们大致明白了，<code>MessageQueue</code>循环取出<code>Message</code>，每个<code>Message</code>都带着一个<code>Handler</code>，由<code>Handler</code>的<code>dispatchMessage(Message msg)</code>来处理该消息。辣么，<code>Handler</code>如何处理这个消息的呢？</p><p>来看看<code>dispatchMessage(Message msg)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出最终执行的地方有三处，先后为：<code>msg.callback</code>, <code>mCallback.handleMessage(msg)</code>和<code>handleMessage(msg)</code>。<code>handleMessage(msg)</code>好理解，因为通常我们都是复写<code>Handler</code>的<code>handleMessage(Message msg)</code>来实现我们更新主线程UI的逻辑，另外两个就比较陌生了，我们一一解析。</p><p><code>msg.callback</code>赋值的地方在两处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.obj = token;</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getPostMessage(Runnable r)</code>和<code>getPostMessage(Runnable r, Object token)</code>这个两个方法又是分别在这些地方调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有熟悉的感觉？没错，这就是我们经常使用的发送更新主线程UI消息的一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>post(Runnable r)</code>、<code>postAtTime(Runnable r, long uptimeMillis)</code>、<code>sendMessageDelayed(Message, delayMillis)</code>……辣么多方法，会不会被搞晕了？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/003.jpg" alt="一脸懵逼" title="">                </div>                <div class="image-caption">一脸懵逼</div>            </figure><p>我们用一张图来梳理一下这些方法</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/004.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>恩，这下清楚多了。</p><p>接下来搜索一下<code>mCallback</code>的出处，其实它是在<code>Handler</code>类的构造函数里被赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图表梳理一下它们之间个关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/005.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中就很明显的看出7个构造方法分为两部分，一部分是默认使用本地线程的<code>Looper</code>对象，另一部分是需要传入一个<code>Looper</code>对象，两部分你都可以传入一个<code>Callback</code>回调，它的定义是在<code>Handler</code>类内部之中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以才会有<code>mCallback.handleMessage(msg)</code>的调用。所以你的<code>Handler</code>实例可以这样实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>跟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实是一个道理。</p><p>到目前为止，我们已经搞懂了消息是如何被处理的——它是由<code>Handler</code>三个部分：Runnable Callback，Callback Function以及Handler Default handleMessage Method其中之一处理的。现在我们回过头来看看消息是如何从<code>MessageQueue</code>取出来的，但首先我们得知道，<code>Message</code>是如何传入队列的。<br>由<a href="#ARM_SEND_MESSAGE_METHOD_RELATIONSHIP">上面发送消息方法的关系图</a>可是知道，无论你是选择哪一种方式发送消息，最终它都会调用<code>enqueueMessage(MessageQueue, Message, long)</code>方法放入队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进入<code>MessageQueue</code>的<code>enqueueMessage(Message, long)</code>方法看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有点长，我们从<code>msg.when = when</code>这一段开始读起，第一个问题就来了，<code>mMessage</code>是干什么的？它的变量声明其实是个<code>Message</code>对象，它有什么作用呢？往下看，有个注释暗示了它的作用——<strong>New head, wake up the event queue if blocked.**意思就不言而喻了，<code>mMessage</code>就是<code>MessageQueue</code>消息队列的</strong>队列头**，往下看接下来的判断语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">    <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们得知道，每个<code>Message</code>都是有自己的处理时间的——<code>when</code>属性，这个<code>when</code>属性决定了这个<code>Message</code>在<code>MessageQueue</code>的位置(<code>Message</code>是根据<code>when</code>来排列的)以及处理的规定时间点，但是有种<code>Message</code>例外，它的<code>when</code>属性是0，由<code>Handler.sendMessageAtFrontOfQueue(Message)</code>发送，从这个方法的命名就可以知道它的意图——希望这个<code>Message</code>排在队列的头部，也就是希望这个消息能够立刻处理。那么这个判断语句我们也应该知道它的意思了：<strong>如果队列头为空或者when为0或者需要处理的时间比队头的时间还要紧迫，则将这个Message作为新的队头</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/006.png" alt="enqueue MessageQueue header 00" title="">                </div>                <div class="image-caption">enqueue MessageQueue header 00</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/007.png" alt="enqueue MessageQueue header 01" title="">                </div>                <div class="image-caption">enqueue MessageQueue header 01</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/looper_message_handler/008.png" alt="enqueue MessageQueue header 02" title="">                </div>                <div class="image-caption">enqueue MessageQueue header 02</div>            </figure><p>再看看<code>else</code>语句，图我也不画了，意思也简单，从队头往后遍历<code>Message</code>，根据<code>when</code>值将新的<code>Message</code>插入到合适的位置。</p><p>看完了<code>MessageQueue.enqueueMessage(Message, long)</code>方法，我们可以探讨一下<code>Message</code>是如何从<code>MessageQueue</code>取出来的了，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands(); <span class="comment">// 阻塞的时间可能很长,确保在此期间释放渲染对象的引用,以免占用空间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); <span class="comment">// 轮询, 阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试检索下一个Message</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="comment">// msg.target为空的情况我不知道, do-while语句是寻找下一个可异步执行的Message</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 下一个Message的可执行时间点未到, 这个Message有两种,一个是队头Message, 另一个是下一个可异步执行的Message</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 得到一个Message,如果是得到可异步执行的Message, prevMsg.next -&gt; msg.next, return msg</span></span><br><span class="line">                    <span class="comment">// 如果是表头,将mMessage指向下一个Message, return msg</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无关（看不懂的）的代码我用省略号代替了，关键部分的代码的意思我写在注释中。到这里，<code>MessageQueue</code>如何去除<code>Message</code>的也已经讲解完了，说白了，就是一个队列的运用而已。最后，打起精神，咬下最后一根硬骨头，<code>Message.recycleUnchecked()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，只是一些清空数据的代码而已，但是注意到一个静态变量没有——<code>sPool</code>，这是什么东西？它的变量声明也是一个<code>Message</code>对象，它是用来干什么的呢？解答疑惑的地方在<code>Message</code>的静态方法<code>obtain</code>里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是<code>Handler.obtainMessage</code>方法，还是<code>Message</code>另外几个<code>obtain</code>方法，最终都会通过调用<code>Message.obtain()</code>这个无参静态方法，它的代码也告诉了我们<code>sPool</code>的作用，它相当于指向一个栈的栈顶，每次使用后的<code>Message</code>实例都会压入这个栈中，每次使用或间接使用<code>Message.obtain()</code>方法都会从栈中弹出一个<code>Message</code>实例，以便做到循环使用，如果不这样子，这个栈就会无限增加<code>Message</code>实例，造成内存泄露，甚至内存溢出，这一点在开发的时候要注意。</p><p>最后我们总结一下研究成果：</p><p>Looper: 它是整个运作的场景，它在主线程中有唯一实例，它内部有唯一的消息队列，由它对整个运作进行初始化，并且调用<code>loop()</code>方法开始循环从消息队列中取消息，处理消息，回收消息。</p><p>MessageQueue: 它相当于一个队列容器，由它接收新的消息，在接收的时候会依照消息指定的处理时间点适当的插入到队列中，在取出的时候可能会因为下一个消息的时间点未到而阻塞。</p><p>Message: 它是一个消息，它由指定处理时间点、辅助处理的数据以及处理对象等元素组成。</p><p>Handler: 它是某个消息的消息处理者，它处理消息的方式有三种，但只能是其中之一处理，它们依次是<code>Runnable</code>的<code>run()</code>方法，<code>Handler</code>的内部类<code>Callback</code>的<code>handleMessage(Message)</code>方法以及<code>Handler</code>的默认方法<code>handleMessage(Message)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Android开发过程中，&lt;code&gt;Message&lt;/code&gt;和&lt;code&gt;Handler&lt;/code&gt;是经常会使用到的类，我们对它们广泛的认知是为了在异步任务中更新主线程的UI，因为在主线程处理耗时的任务是会ANR的。&lt;code&gt;Message&lt;/code&gt;和&lt;co</summary>
      
    
    
    
    <category term="Android" scheme="https://dylantseng.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://dylantseng.github.io/tags/Android/"/>
    
    <category term="Looper" scheme="https://dylantseng.github.io/tags/Looper/"/>
    
    <category term="Message" scheme="https://dylantseng.github.io/tags/Message/"/>
    
    <category term="Handler" scheme="https://dylantseng.github.io/tags/Handler/"/>
    
    <category term="MessageQueue" scheme="https://dylantseng.github.io/tags/MessageQueue/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Android Theme的那些事</title>
    <link href="https://dylantseng.github.io/2017/01/12/ckl5e1aze00076dz16qytb6ky/"/>
    <id>https://dylantseng.github.io/2017/01/12/ckl5e1aze00076dz16qytb6ky/</id>
    <published>2017-01-12T07:26:50.000Z</published>
    <updated>2021-02-14T14:01:43.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>话说Android里面的主题真是琳琅满目，虽然平时开发时我们都是固定，约定成熟的使用某个主题，例如官方推荐的AppComat系列，但是Android有多少主题，它们之间有什么联系和区别很少人去认真探究。我本人开发时都是直接使用Android Studio生成的主题，或者是继承至它。Holo主题基本没有使用过，似乎是一个比较老的主题，比我早接触Android的前辈们应该比较熟悉。Material主题就属于比较新的主题。还有呢？</p><h2 id="2-一些主要的根主题以及它的继承结构"><a href="#2-一些主要的根主题以及它的继承结构" class="headerlink" title="2. 一些主要的根主题以及它的继承结构"></a>2. 一些主要的根主题以及它的继承结构</h2><p>这里我使用了“根主题”的说法，因为大多数主题都是继承至某个主题，追根究底，会找到几个没有parent的根主题。我们来看看这几个根主题：</p><ul><li><p><strong>Theme</strong>：API 10及其以下的默认主题。</p></li><li><p><strong>Theme.Holo</strong>：API 11 - 13的默认主题，</p></li><li><p><strong>Theme.Material</strong>：API 21及其以上。</p></li></ul><h3 id="2-1-如何追溯到这些Theme？"><a href="#2-1-如何追溯到这些Theme？" class="headerlink" title="2.1 如何追溯到这些Theme？"></a>2.1 如何追溯到这些Theme？</h3><p>你可以随便新建一个Theme，parent继承至<code>Theme.AppCompat</code>，按住<code>Ctrl</code>(在Mac上是<code>Command</code>)点击parent主题，这样一直追溯到<code>Platform.AppComat</code>会有几个选择：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/001.jpg" alt="platform version list" title="">                </div>                <div class="image-caption">platform version list</div>            </figure><p>到这里，Theme的继承就区别开来了，<code>/values.xml</code>最终会继承至<code>Theme</code>，<code>/values-v11.xml</code>和<code>/values-v14.xml</code>最终会继承至<code>Theme.Holo</code>，而<code>/values-v21.xml</code>会继承至<code>Theme.Material</code>。所以说，一般我们选择主题选择继承至<code>AppCompat</code>系列的主题就可以了(至少现在是如此)，<code>AppCompat</code>已经做好适配工作了。</p><h3 id="2-2-它们有什么区别呢"><a href="#2-2-它们有什么区别呢" class="headerlink" title="2.2 它们有什么区别呢?"></a>2.2 它们有什么区别呢?</h3><p>据我所对比观察，它们的参数基本上相同：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/002.jpg" alt="Theme diff" title="">                </div>                <div class="image-caption">Theme diff</div>            </figure><p>双方有些细微的增缺，只有值大不一样，但这并不影响什么，我们必要的时候直接去所关心的Theme那里了解一下目标参数。<strong>一个主题规范严格的app，风格的定义应该在App Theme上就得到了统一</strong>，这些根主题的参数给了我们修改，参考的依据，了解这些参数是很有必要的。</p><h3 id="2-3-只有这些根主题吗"><a href="#2-3-只有这些根主题吗" class="headerlink" title="2.3 只有这些根主题吗?"></a>2.3 只有这些根主题吗?</h3><p>当然，Android系统如此庞杂，远远不止这些根主题，上述3个根主题所在的xml文件里定义了很多根主题，适当了解一下会有好处。</p><h3 id="2-4-如此多的子主题，我们该如何抉择？看看它的继承结构。"><a href="#2-4-如此多的子主题，我们该如何抉择？看看它的继承结构。" class="headerlink" title="2.4 如此多的子主题，我们该如何抉择？看看它的继承结构。"></a>2.4 如此多的子主题，我们该如何抉择？看看它的继承结构。</h3><p>我先贴上一张自己总结的图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/003.png" alt="theme construction" title="">                </div>                <div class="image-caption">theme construction</div>            </figure><p>我以<code>AppCompat</code>系列的主题为例，图中并没有将所有主题都收拢进去，毕竟太多了。图中枝节点的依据是这样子：例如<code>Base.TextAppearance.AppCompat.Widget.Actionbar.Subtitle.Inverse</code>这个style，已<code>.</code>为分割线，<code>Base</code>、<code>TextAppearance</code>…为节点作成的结构图。从图中可以很直观的得出结论：主题分为<code>TextAppearance</code>、<code>Theme</code>、<code>ThemeOverlay</code>和<code>Widget</code>4种。</p><ul><li><p><strong>TextAppeareance</strong>: 定义字体样式。</p></li><li><p><strong>Theme</strong>: 定义Dialog和Application的样式。</p></li><li><p><strong>ThemeOverlay</strong>: 定义悬浮层的样式，例如点击<strong>ActionBar</strong>上的更多或者下拉菜单弹出的悬浮界面的样式。</p></li><li><p><strong>Widget</strong>：顾名思义，定义<code>Button</code>之类的组件的样式。</p></li></ul><p>如果你想使用某个字体主题或者自定义，你可以使用或者继承<strong>TextAppearance</strong>系列：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/004.jpg" alt="TextAppearance Theme" title="">                </div>                <div class="image-caption">TextAppearance Theme</div>            </figure><p>同样的<strong>Theme</strong>系列：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/005.jpg" alt="Theme Theme" title="">                </div>                <div class="image-caption">Theme Theme</div>            </figure><p><strong>ThemeOverlay</strong>系列：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/006.jpg" alt="ThemeOverlay Theme" title="">                </div>                <div class="image-caption">ThemeOverlay Theme</div>            </figure><p><strong>Widget</strong>系列：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/007.jpg" alt="Widget Theme" title="">                </div>                <div class="image-caption">Widget Theme</div>            </figure><p>Android的Style命名已经极大的便利我们使用，我们唯一要做的事就是根据业务需求了解某个主题的参数和值，并且在必要的时候复写它。</p><h2 id="3-自定义样式"><a href="#3-自定义样式" class="headerlink" title="3 自定义样式"></a>3 自定义样式</h2><p>现在用实际行动来验证我们的猜想。我新建了一个Activity，它是这样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/008.png" alt="origin" title="">                </div>                <div class="image-caption">origin</div>            </figure><p><code>Activity</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionBarActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bind(R.id.toolbar)</span> Toolbar mToolbar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_action_bar);</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mToolbar.setTitle(<span class="string">&quot;Thanatosx&quot;</span>);</span><br><span class="line">        mToolbar.setSubtitle(<span class="string">&quot;Widgets&quot;</span>);</span><br><span class="line"></span><br><span class="line">        setSupportActionBar(mToolbar);</span><br><span class="line"></span><br><span class="line">        ActionBar mActionBar = getSupportActionBar();</span><br><span class="line">        <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mActionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">            mActionBar.setHomeButtonEnabled(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        getMenuInflater().inflate(R.menu.menus, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layout布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:background=&quot;#80123456&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及Theme主题：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowActionBar&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们想要通过修改Theme来改变Toolbar的样式达到以下效果：</p><ul><li><p>改变返回图标</p></li><li><p>改变Title和Subtitle的字体大小和颜色</p></li><li><p>改变more icon的颜色</p></li></ul><p>首先，第一个问题是：去哪里修改？前面说到，Theme主题基本可以定义一个Application的大部分地方的样式，我们需要去搜索一下父主题是否有这样的定义，从<code>Theme.AppCompat.Light</code>这个主题开始往上追溯，在<code>Base.Theme.AppCompat.Light</code>上会有个版本选择：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/009.jpg" alt="show version list" title="">                </div>                <div class="image-caption">show version list</div>            </figure><p>这个无所谓，选择低版本的就可以了，低版本都支持的话就不用担心高版本，首先会在<code>Base.v7.Theme.AppCompat.Light</code>上发现Toolbar Style的定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/010.jpg" alt="found out toolbar style" title="">                </div>                <div class="image-caption">found out toolbar style</div>            </figure><p>那么，我们就可以复写这个属性，自定义我们的Toolbar Style了，同样的，有个<code>actionOverflowButtonStyle</code>属性，它就是定义more icon button的属性了。</p><p>修改后的Theme：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowActionBar&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;actionOverflowButtonStyle&quot;</span>&gt;</span>@style/AppWidget.ActionButton.Overflow<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;toolbarStyle&quot;</span>&gt;</span>@style/AppTheme.Toolbar<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme.Toolbar&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.AppCompat.Toolbar&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:minHeight&quot;</span>&gt;</span>50dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;titleTextAppearance&quot;</span>&gt;</span>@style/AppTextAppearance.Widget.Actionbar.Title<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;subtitleTextAppearance&quot;</span>&gt;</span>@style/AppTextAppearance.Widget.Actionbar.Subtitle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;navigationIcon&quot;</span>&gt;</span>@mipmap/ic_back<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:background&quot;</span>&gt;</span>?attr/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTextAppearance.Widget.Actionbar.Title&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;TextAppearance.Widget.AppCompat.Toolbar.Title&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>14sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>#FFF<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTextAppearance.Widget.Actionbar.Subtitle&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;TextAppearance.Widget.AppCompat.Toolbar.Subtitle&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>12sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>#FFF<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppWidget.ActionButton.Overflow&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.AppCompat.ActionButton.Overflow&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:src&quot;</span>&gt;</span>@mipmap/ic_more<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>parent继承至原使用的Style Theme，以此基础上重写自己需要修改的属性，最终效果图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/011.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="4-坑"><a href="#4-坑" class="headerlink" title="4 坑"></a>4 坑</h2><p>在修改Activity的返回按钮的时候我在<code>AppTheme</code>里找到这个属性：<code>homeAsUpIndicator</code>，老司机们肯定明白，这就是设置返回按钮的图标，但是无论我如何设置，修改，这个属性没有任何效果！！无奈之下，我去overflowstack上寻找答案，众说纷纭，倒是看到这个属性<code>navigationIcon</code>，我在Theme上没看到，在Toolbar的主题上也没有看到，但是当我进入Toolbar的源码，我发现是有这个属性的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/012.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我直接跑去R.java文件去看，一目了然：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/android_theme/013.jpg" alt="r.java" title="">                </div>                <div class="image-caption">r.java</div>            </figure><p><strong>源码之下，没有秘密</strong></p><p>还有一点，设置<code>navigationIcon</code>之后，点击返回按钮没有任何响应了，需要设置Navigation Click Listener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after set support action bar</span></span><br><span class="line">mToolbar.setNavigationOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;话说Android里面的主题真是琳琅满目，虽然平时开发时我们都是固定，约定成熟的使用某个主题，例如官方推荐的AppCom</summary>
      
    
    
    
    <category term="Android" scheme="https://dylantseng.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://dylantseng.github.io/tags/Android/"/>
    
    <category term="Theme" scheme="https://dylantseng.github.io/tags/Theme/"/>
    
  </entry>
  
  <entry>
    <title>FragmentPagerAdapter与FragmentStatePagerAdapter的差异</title>
    <link href="https://dylantseng.github.io/2017/01/12/ckl5e1az500016dz17mgv4usg/"/>
    <id>https://dylantseng.github.io/2017/01/12/ckl5e1az500016dz17mgv4usg/</id>
    <published>2017-01-12T07:23:55.000Z</published>
    <updated>2021-02-14T14:01:43.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><code>PagerAdapter</code>是提供计算<code>ViewPager</code>内的Pages的适配器，而<code>FragmentPagerAdapter</code>与<code>FragmentStatePagerAdapter</code>都是继承至<br><code>PagerAdapter</code>这个基类，是<code>PagerAdapter</code>的两个特殊实现。可能有些人会断章取义的认为<code>FragmentPagerAdapter</code>不会保存<code>Fragment</code>的状态，而<code>FragmentStatePagerAdapter</code>会维持<code>Fragment</code>的状态。事实上，这是一种错误的理解，虽然你在使用时并不会有什么影响。<code>FragmentPagerAdapter</code>与<code>FragmentStatePagerAdapter</code>的实现跟它们所要服务的场景有密切的关系，我们通过理解二者的源码来了解设计者的设计目的。</p><h2 id="2、FragmentPagerAdapter"><a href="#2、FragmentPagerAdapter" class="headerlink" title="2、FragmentPagerAdapter"></a>2、<strong>FragmentPagerAdapter</strong></h2><p>首先先贴上源代码，代码量不是很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentPagerAdapter</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;FragmentPagerAdapter&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FragmentManager mFragmentManager;</span><br><span class="line">    <span class="keyword">private</span> FragmentTransaction mCurTransaction = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Fragment mCurrentPrimaryItem = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FragmentPagerAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        mFragmentManager = fm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the Fragment associated with a specified position.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUpdate</span><span class="params">(ViewGroup container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (container.getId() == View.NO_ID) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;ViewPager with adapter &quot;</span> + <span class="keyword">this</span></span><br><span class="line">                    + <span class="string">&quot; requires a view id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">        String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">        Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Attaching item #&quot;</span> + itemId + <span class="string">&quot;: f=&quot;</span> + fragment);</span><br><span class="line">            mCurTransaction.attach(fragment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fragment = getItem(position);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Adding item #&quot;</span> + itemId + <span class="string">&quot;: f=&quot;</span> + fragment);</span><br><span class="line">            mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                    makeFragmentName(container.getId(), itemId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">            fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Detaching item #&quot;</span> + getItemId(position) + <span class="string">&quot;: f=&quot;</span> + object</span><br><span class="line">                + <span class="string">&quot; v=&quot;</span> + ((Fragment)object).getView());</span><br><span class="line">        mCurTransaction.detach((Fragment)object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">        Fragment fragment = (Fragment)object;</span><br><span class="line">        <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCurrentPrimaryItem.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fragment.setMenuVisibility(<span class="keyword">true</span>);</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentPrimaryItem = fragment;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishUpdate</span><span class="params">(ViewGroup container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurTransaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurTransaction.commitNowAllowingStateLoss();</span><br><span class="line">            mCurTransaction = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View view, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Fragment)object).getView() == view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Parcelable <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(Parcelable state, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a unique identifier for the item at the given position.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation returns the given position.</span></span><br><span class="line"><span class="comment">     * Subclasses should override this method if the positions of items can change.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position Position within this adapter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Unique identifier for the item at position</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">makeFragmentName</span><span class="params">(<span class="keyword">int</span> viewId, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;android:switcher:&quot;</span> + viewId + <span class="string">&quot;:&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把目光聚焦到这几个主要的方法：</p><ul><li><code>public Object instantiateItem(ViewGroup container, int position)</code></li><li><code>public void destroyItem(ViewGroup container, int position, Object object)</code></li><li><code>public void finishUpdate(ViewGroup container)</code></li><li><code>public Parcelable saveState()</code></li><li><code>public void restoreState(Parcelable state, ClassLoader loader)</code></li></ul><p>方法<code>saveState</code>和<code>restoreState</code>并没有干什么事情，但是在<code>FragmentStatePagerAdapter</code>中就大不一样，所以现在先注意这两个方法。<br><code>finishUpdate</code>当已显示的pages完成改变后调用，一般在这个方法内commit <code>FragmentTransaction</code>的操作。我们首先看看<code>instantiateItem</code><br>方法的源代码，它是用来实例化某个item的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> itemId = getItemId(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do we already have this fragment?</span></span><br><span class="line">    String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    Fragment fragment = mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Attaching item #&quot;</span> + itemId + <span class="string">&quot;: f=&quot;</span> + fragment);</span><br><span class="line">        mCurTransaction.attach(fragment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragment = getItem(position);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Adding item #&quot;</span> + itemId + <span class="string">&quot;: f=&quot;</span> + fragment);</span><br><span class="line">        mCurTransaction.add(container.getId(), fragment,</span><br><span class="line">                makeFragmentName(container.getId(), itemId));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先获得一个<code>itemId</code>（实际上返回时的position本身），然后作为参数传入makeFragmentName方法生成一个<strong>name</strong>，然后使用这个<strong>name</strong><br>在<code>FragmentManager</code>内搜索出Fragment，如果不为空，说明以前加入过，那么重新attach这个Fragment，如果为空，那么使用<code>getItem</code>创建一个，<code>getItem</code><br>就是需要我们自己实现的抽象方法之一，最后将新创建的<code>Fragment</code> add进去。</p><p> 既然<code>FragmentPagerAdapter</code>实例化item得方式是通过<code>add</code>或者<code>attach</code>，那么，显而易见，在<code>destroyItem</code>内必定是使用<code>detach</code>来‘卸载’item：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Detaching item #&quot;</span> + getItemId(position) + <span class="string">&quot;: f=&quot;</span> + object</span><br><span class="line">            + <span class="string">&quot; v=&quot;</span> + ((Fragment)object).getView());</span><br><span class="line">    mCurTransaction.detach((Fragment)object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，很简单的操作，使用<code>FragmentTransaction</code> attach了需要销毁的Fragment。</p><p><code>FragmentPagerAdapter</code>整个流程很简单，就是 add -&gt; detach -&gt; attach -&gt; detach -&gt; …因为走的是<code>detach</code>和<code>attach</code>的路，所以系统会保存<code>Fragment</code>的State。<code>FragmentPagerAdapter</code>是很普通的一个<code>PagerAdapter</code>的实现类，适用于基本的使用场景，但是如果是有大量的Tab的使用场景，<code>FragmentPagerAdapter</code>就不太适用了，因为它的状态都用系统保存常驻在内存之中了，并且<code>Fragment</code>的实例也常驻在内存，所以会导致大量的内存占用。</p><p><code>FragmentStatePagerAdapter</code>就解决<code>FragmentPagerAdapter</code>短板的问题。</p><h2 id="3、FragmentStatePagerAdapter"><a href="#3、FragmentStatePagerAdapter" class="headerlink" title="3、FragmentStatePagerAdapter"></a>3、<strong>FragmentStatePagerAdapter</strong></h2><p><code>FragmentStatePagerAdapter</code>相对<code>FragmentPagerAdapter</code>多了两个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Fragment.SavedState&gt; mSavedState = <span class="keyword">new</span> ArrayList&lt;Fragment.SavedState&gt;();</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Fragment&gt; mFragments = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br></pre></td></tr></table></figure><p>意图很明显了，<code>mFragments</code>用来保存<code>Fragment</code>的实例，<code>mSavedState</code>用来保存每个<code>Fragment</code>的状态，我们接下来看看<code>instantiateItem</code>和<code>destroyItem</code><br>这两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we already have this item instantiated, there is nothing</span></span><br><span class="line">    <span class="comment">// to do.  This can happen when we are restoring the entire pager</span></span><br><span class="line">    <span class="comment">// from its saved state, where the fragment manager has already</span></span><br><span class="line">    <span class="comment">// taken care of restoring the fragments we previously had instantiated.</span></span><br><span class="line">    <span class="keyword">if</span> (mFragments.size() &gt; position) &#123;</span><br><span class="line">        Fragment f = mFragments.get(position);</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fragment fragment = getItem(position);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Adding item #&quot;</span> + position + <span class="string">&quot;: f=&quot;</span> + fragment);</span><br><span class="line">    <span class="keyword">if</span> (mSavedState.size() &gt; position) &#123;</span><br><span class="line">        Fragment.SavedState fss = mSavedState.get(position);</span><br><span class="line">        <span class="keyword">if</span> (fss != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fragment.setInitialSavedState(fss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (mFragments.size() &lt;= position) &#123;</span><br><span class="line">        mFragments.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">    fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">    mFragments.set(position, fragment);</span><br><span class="line">    mCurTransaction.add(container.getId(), fragment);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FragmentStatePagerAdapter</code>首先会在<code>mFragments</code>集合内寻找对应position的<code>Fragment</code>，如果position大于该集合的size，说明该position下的<code>Fragment</code>从未被访问过，那么就会执行<code>getItem</code>创建新的实例。如果position在<code>mSavedState</code>集合范围内，说明改<code>Fragment</code>曾经访问过，并且有它以前的状态，那么，还原这个状态。最后加入<code>FragmentManager</code>之中。再来看看<code>destroyItem</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">    Fragment fragment = (Fragment) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Removing item #&quot;</span> + position + <span class="string">&quot;: f=&quot;</span> + object</span><br><span class="line">            + <span class="string">&quot; v=&quot;</span> + ((Fragment)object).getView());</span><br><span class="line">    <span class="keyword">while</span> (mSavedState.size() &lt;= position) &#123;</span><br><span class="line">        mSavedState.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mSavedState.set(position, fragment.isAdded()</span><br><span class="line">            ? mFragmentManager.saveFragmentInstanceState(fragment) : <span class="keyword">null</span>);</span><br><span class="line">    mFragments.set(position, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    mCurTransaction.remove(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于<code>FragmentPagerAdapter</code>，<code>FragmentStatePagerAdapter</code>是采用<code>remove</code>的方式销毁<code>Fragment</code>，但实际上，活动的<code>Fragment</code>实例保存在<code>mFragments</code>之中，在<code>destroyItem</code>方法内又会被移除，但是状态不会被删除，总是保存在<code>mSavedState</code>集合之中。所以，<code>FragmentStatePagerAdapter</code>的机制是: add -&gt; save state -&gt; remove -&gt; initial state -&gt; add -&gt; …</p><p>这里有也暴露了<code>FragmentStatePagerAdapter</code>两个致命的问题：一是状态不会被删除，总是保存在<code>mSavedState</code>集合中，如果一个<code>ViewPager</code>像网易新闻那样有几十个Tab，势必会造成内存压力。二是不能做移除Tab的工作，即使你移除的某个Tab以及相关的<code>Fragment</code>，状态依然没有删除，我们又不能删除，没有相关的API，同时，例如你删除了position为2的<code>Fragment</code>,原本position为3的<code>Fragment</code>就会使用position为2的<code>Fragment</code>的状态。这是很致命的问题。</p><h2 id="4、区别在哪？"><a href="#4、区别在哪？" class="headerlink" title="4、区别在哪？"></a>4、区别在哪？</h2><p><code>FragmentPagerAdapter</code>和<code>FragmentStatePagerAdapter</code>的机制决定了它们的区别。<code>FragmentPagerAdapter</code>使用<code>add</code>, <code>attach</code>, <code>detach</code>来管理<code>Fragment</code>，<code>Fragment</code>实例和状态都被保存下来，但是重建的消耗不高，生命周期在onAttach和onDetach间游走，典型的用内存换效率的做法。而<code>FragmentStatePagerAdapter</code>使用<code>add</code>, <code>remove</code>来管理<code>Fragment</code>，被销毁的<code>Fragment</code>实例不再存在，但是其状态保存在集合之中，以便下次重新创建实例时能够还原之前的状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PagerAdapter&lt;/code&gt;是提供计算&lt;code&gt;ViewPager&lt;/code&gt;内的Pages的适配</summary>
      
    
    
    
    <category term="Android" scheme="https://dylantseng.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://dylantseng.github.io/tags/Android/"/>
    
    <category term="ViewPager" scheme="https://dylantseng.github.io/tags/ViewPager/"/>
    
    <category term="Adapter" scheme="https://dylantseng.github.io/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>基本排序(C语言版)</title>
    <link href="https://dylantseng.github.io/2017/01/12/ckl5e1az900036dz11xjk6ye4/"/>
    <id>https://dylantseng.github.io/2017/01/12/ckl5e1az900036dz11xjk6ye4/</id>
    <published>2017-01-12T06:47:03.000Z</published>
    <updated>2021-02-14T14:01:43.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 冒泡排序 logN^2</span></span><br><span class="line"><span class="comment">* 基本思路：每次从数组底端将最小的数“冒”上来</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>; j&gt;i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*(p+j)&lt;*(p+j<span class="number">-1</span>))&#123;</span><br><span class="line">                *(p+j) ^= *(p+j<span class="number">-1</span>);</span><br><span class="line">                *(p+j<span class="number">-1</span>) ^= *(p+j);</span><br><span class="line">                *(p+j) ^= *(p+j<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 选择排序 logN^2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>; j&gt;i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*(p+j)&lt;*(p+min)) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            *(p+i) ^= *(p+min);</span><br><span class="line">            *(p+min) ^= *(p+i);</span><br><span class="line">            *(p+i) ^= *(p+min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 插入排序 logN^2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*(p+j)&lt;*(p+j<span class="number">-1</span>))&#123;</span><br><span class="line">                *(p+j) ^= *(p+j<span class="number">-1</span>);</span><br><span class="line">                *(p+j<span class="number">-1</span>) ^= *(p+j);</span><br><span class="line">                *(p+j) ^= *(p+j<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 希尔排序 N^1.5</span></span><br><span class="line"><span class="comment">* 基本思路：选取某个增量，将数组分为若干的子序列，对子序列进行插入排序，</span></span><br><span class="line"><span class="comment">* 逐渐减小增量，重复上述操作，直到增量为1，此时数组基本有序，最后进行一次插入排序。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> incre=len/<span class="number">2</span>; incre&gt;=<span class="number">1</span>; incre--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;incre; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+incre; j&lt;len; j+=incre)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j; k&gt;i; k-=incre)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(*(p+k)&lt;*(p+k-incre))&#123;</span><br><span class="line">                        *(p+k) ^= *(p+k-incre);</span><br><span class="line">                        *(p+k-incre) ^= *(p+k);</span><br><span class="line">                        *(p+k) ^= *(p+k-incre);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 快速排序 N*logN</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = p;</span><br><span class="line">    <span class="keyword">int</span> *e = p + len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sentry = *p;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;e)&#123;</span><br><span class="line">        <span class="keyword">while</span>(b&lt;e &amp;&amp; *e &gt;= sentry) e--;</span><br><span class="line">        *b = *e;</span><br><span class="line">        <span class="keyword">while</span>(b&lt;e &amp;&amp; *b &lt;= sentry) b++;</span><br><span class="line">        *e = *b;</span><br><span class="line">    &#125;</span><br><span class="line">    *b = sentry;</span><br><span class="line">    QuickSort(p, b-p);</span><br><span class="line">    QuickSort(b+<span class="number">1</span>, len-(b-p)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 归并排序 N*logN</span></span><br><span class="line"><span class="comment">* 需要额外的空间存放数据</span></span><br><span class="line"><span class="comment">* 基本思想：将一个数组分成两份，如果这两份数组的有序的，那么将这两份数组归并，</span></span><br><span class="line"><span class="comment">* 对上述操作进行递归操作，直到分成的数组仅仅只有一个元素，那么它理所当然是有序的。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len1, <span class="keyword">int</span> *q, <span class="keyword">int</span> len2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[len1+len2];</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i = j = k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(p+i)&lt;*(q+j))&#123;</span><br><span class="line">            temp[k++] = *(p+i++);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = *(q+j++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1) temp[k++] = *(p+i++);</span><br><span class="line">    <span class="keyword">while</span>(j&lt;len2) temp[k++] = *(q+j++);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len1+len2; i++) *(p+i) = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = len/<span class="number">2</span>;</span><br><span class="line">    MergeSort(p, middle);</span><br><span class="line">    MergeSort(p+middle, len-middle);</span><br><span class="line">    MergeArray(p, middle, p+middle, len-middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 堆排序 N * logN</span></span><br><span class="line"><span class="comment">* len/2 -1 最后一个节点的父节点</span></span><br><span class="line"><span class="comment">* 2*i + 1 左孩子节点</span></span><br><span class="line"><span class="comment">* 2*i + 2 右孩子节点</span></span><br><span class="line"><span class="comment">* 基本思路：将一个数组看作是完全二叉树，先调整整个堆，然后将根节点和</span></span><br><span class="line"><span class="comment">* 末节点互换，重新调整堆</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(child&gt;=len) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(child&lt;len<span class="number">-1</span> &amp;&amp; *(p+child)&lt;*(p+child+<span class="number">1</span>)) child++;</span><br><span class="line">    <span class="keyword">if</span>(*(p+i)&lt;*(p+child))&#123;</span><br><span class="line">        *(p+i) ^= *(p+child);</span><br><span class="line">        *(p+child) ^= *(p+i);</span><br><span class="line">        *(p+i) ^= *(p+child);</span><br><span class="line">        HeapAdjust(p, len, child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先先从最后一个节点的父节点开始调整堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) HeapAdjust(p, len, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        *p ^= *(p+i);</span><br><span class="line">        *(p+i) ^= *p;</span><br><span class="line">        *p ^= *(p+i);</span><br><span class="line">        HeapAdjust(p, i, <span class="number">0</span>); <span class="comment">// &lt;--not i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://dylantseng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://dylantseng.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="算法" scheme="https://dylantseng.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
